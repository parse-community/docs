# Push Notifications

Push Notifications are a great way to keep your users engaged and informed about your app. You can reach your entire user base quickly and effectively. This guide will help you through the setup process and the general usage of Parse to send push notifications.

If you haven't installed the SDK yet, please [head over to the Push QuickStart](/apps/quickstart_push) to get our SDK up and running.

## Setting Up Push

If you want to start using push, start by completing the [iOS Push tutorial](/tutorials/ios-push-notifications) to learn how to configure your app. Come back to this guide afterwards to learn more about the push features offered by Parse.

## Installations

Every Parse application installed on a device registered for push notifications has an associated `Installation` object. The `Installation` object is where you store all the data needed to target push notifications. For example, in a baseball app, you could store the teams a user is interested in to send updates about their performance. Saving the `Installation` object is also required for tracking push-related app open events.

In iOS, `Installation` objects are available through the `PFInstallation` class, a subclass of `PFObject`. It uses the [same API](#objects) for storing and retrieving data. To access the current `Installation` object from your iOS app, use the `[PFInstallation currentInstallation]` method. The first time you save a `PFInstallation`, Parse will add it to your `Installation` class, and it will be available for targeting push notifications as long as its `deviceToken` field is set.

First, make your app register for remote notifications by adding the following in your `application:didFinishLaunchingWithOptions:` method (if you haven't already):

```objc
UIUserNotificationType userNotificationTypes = (UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound);
UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:userNotificationTypes  categories:nil];
[application registerUserNotificationSettings:settings];
[application registerForRemoteNotifications];
```
```swift
let userNotificationTypes = (UIUserNotificationType.Alert |  UIUserNotificationType.Badge |  UIUserNotificationType.Sound);

let settings = UIUserNotificationSettings(forTypes: userNotificationTypes, categories: nil)
application.registerUserNotificationSettings(settings)
application.registerForRemoteNotifications()
```

We will then update our `PFInstallation` with the `deviceToken` once the device is registered for push notifications:

```objc
- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
	// Store the deviceToken in the current Installation and save it to Parse
	PFInstallation *currentInstallation = [PFInstallation currentInstallation];
	[currentInstallation setDeviceTokenFromData:deviceToken];
	[currentInstallation saveInBackground];
}
```
```swift
func application(application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData) {
	// Store the deviceToken in the current Installation and save it to Parse
	let installation = PFInstallation.currentInstallation()
	installation.setDeviceTokenFromData(deviceToken)
	installation.saveInBackground()
}
```

While it is possible to modify a `PFInstallation` just like you would a `PFObject`, there are several special fields that help manage and target devices.

*   **`badge`**: The current value of the icon badge for iOS apps. Changing this value on the `PFInstallation` will update the badge value on the app icon. Changes should be saved to the server so that they will be used for future badge-increment push notifications.
*   **`channels`**: An array of the channels to which a device is currently subscribed.
*   **`timeZone`**: The current time zone where the target device is located. This value is synchronized every time an `Installation` object is saved from the device _(readonly)_.
*   **`deviceType`**: The type of device, "ios", "android", "winrt", "winphone", or "dotnet"_(readonly)_.
*   **`pushType`**: This field is reserved for directing Parse to the push delivery network to be used. If the devic is registered to receive pushes via GCM, this field will be marked "gcm". If this device is not using GCM, and is using Parse's push notification service, it will be blank _(readonly)_.
*   **`installationId`**: Unique Id for the device used by Parse _(readonly)_.
*   **`deviceToken`**: The Apple generated token used for iOS devices _(readonly)_.
*   **`channelUris`**: The Microsoft-generated push URIs for Windows devices _(readonly)_.
*   **`appName`**: The display name of the client application to which this installation belongs _(readonly)_.
*   **`appVersion`**: The version string of the client application to which this installation belongs _(readonly)_.
*   **`parseVersion`**: The version of the Parse SDK which this installation uses _(readonly)_.
*   **`appIdentifier`**: A unique identifier for this installation's client application. In iOS, this is the Bundle Identifier _(readonly)_.

## Sending Pushes

There are two ways to send push notifications using Parse: [channels](#push-notifications-using-channels) and [advanced targeting](#push-notifications-using-advanced-targeting). Channels offer a simple and easy to use model for sending pushes, while advanced targeting offers a more powerful and flexible model. Both are fully compatible with each other and will be covered in this section.

Sending notifications is often done from the Parse.com push console, the [REST API](/docs/rest/guide#push-notifications-sending-pushes) or from [Cloud Code](/docs/js/guide#push-notifications-sending-pushes). However, push notifications can also be triggered by the existing client SDKs. If you decide to send notifications from the client SDKs, you will need to set **Client Push Enabled** in the Push Notifications settings of your Parse app.

However, be sure you understand that enabling Client Push can  lead to a security vulnerability in your app, as outlined [on our blog](http://blog.parse.com/2014/09/03/the-dangerous-world-of-client-push/).  We recommend that you enable Client Push for testing purposes only,  and move your push notification logic into Cloud Code  when your app is ready to go into production.

![](/images/docs/client_push_settings.png)

You can view your past push notifications on the Parse.com push console for up to 30 days after creating your push.  For pushes scheduled in the future, you can delete the push on the push console as long as no sends have happened yet. After you send the push, the push console shows push analytics graphs.

### Using Channels

The simplest way to start sending notifications is using channels. This allows you to use a publisher-subscriber model for sending pushes. Devices start by subscribing to one or more channels, and notifications can later be sent to these subscribers. The channels subscribed to by a given `Installation` are stored in the `channels` field of the `Installation` object.

#### Subscribing to Channels

A channel is identified by a string that starts with a letter and consists of alphanumeric characters, underscores, and dashes. It doesn't need to be explicitly created before it can be used and each `Installation` can subscribe to any number of channels at a time.

Adding a channel subscription can be done using the `addUniqueObject:` method in `PFObject`. For example, in a baseball score app, we could do:

```objc
// When users indicate they are Giants fans, we subscribe them to that channel.
PFInstallation *currentInstallation = [PFInstallation currentInstallation];
[currentInstallation addUniqueObject:@"Giants" forKey:@"channels"];
[currentInstallation saveInBackground];
```
```swift
// When users indicate they are Giants fans, we subscribe them to that channel.
let currentInstallation = PFInstallation.currentInstallation()
currentInstallation.addUniqueObject("Giants" forKey: "channels")
currentInstallation.saveInBackground()
```

Once subscribed to the "Giants" channel, your `Installation` object should have an updated `channels` field.

![](/images/docs/installation_channel.png)

Unsubscribing from a channel is just as easy:

```objc
// When users indicate they are no longer Giants fans, we unsubscribe them.
PFInstallation *currentInstallation = [PFInstallation currentInstallation];
[currentInstallation removeObject:@"Giants" forKey:@"channels"];
[currentInstallation saveInBackground];
```
```swift
// When users indicate they are Giants fans, we subscribe them to that channel.
let currentInstallation = PFInstallation.currentInstallation()
currentInstallation.removeObject("Giants" forKey: "channels")
currentInstallation.saveInBackground()
```

The set of subscribed channels is cached in the `currentInstallation` object:

```objc
NSArray *subscribedChannels = [PFInstallation currentInstallation].channels;
```
```swift
let subscribedChannels = PFInstallation.currentInstallation().channels
```

If you plan on changing your channels from Cloud Code or the data browser, note that you'll need to call some form of `fetch` prior to this line in order to get the most recent channels.

#### Sending Pushes to Channels

In the iOS SDK, the following code can be used to alert all subscribers of the "Giants" channel that their favorite team just scored. This will display a notification center alert to iOS users and a system tray notification to Android users.

```objc
// Send a notification to all devices subscribed to the "Giants" channel.
PFPush *push = [[PFPush alloc] init];
[push setChannel:@"Giants"];
[push setMessage:@"The Giants just scored!"];
[push sendPushInBackground];
```
```swift
// Send a notification to all devices subscribed to the "Giants" channel.
let push = PFPush()
push.setChannel("Giants")
push.setMessage("The Giants just scored!")
push.sendPushInBackground()
```

If you want to target multiple channels with a single push notification, you can use an `NSArray` of channels.

```objc
NSArray *channels = [NSArray arrayWithObjects:@"Giants", @"Mets", nil];
PFPush *push = [[PFPush alloc] init];

// Be sure to use the plural 'setChannels'.
[push setChannels:channels];
[push setMessage:@"The Giants won against the Mets 2-3."];
[push sendPushInBackground];
```
```swift
let channels = [ "Giants", "Mets" ];
let push = PFPush()

// Be sure to use the plural 'setChannels'.
push.setChannels(channels)
push.setMessage("The Giants won against the Mets 2-3.")
push.sendPushInBackground()
```

### Using Advanced Targeting

While channels are great for many applications, sometimes you need more precision when targeting the recipients of your pushes. Parse allows you to write a query for any subset of your `Installation` objects using the [querying API](#queries) and to send them a push.

Since `PFInstallation` is a subclass of `PFObject`, you can save any data you want and even create relationships between `Installation` objects and your other objects. This allows you to send pushes to a very customized and dynamic segment of your user base.

#### Saving Installation Data

Storing data on an `Installation` object is just as easy as storing [any other data](#objects) on Parse. In our Baseball app, we could allow users to get pushes about game results, scores and injury reports.

```objc
// Store app language and version
PFInstallation *installation = [PFInstallation currentInstallation];
[installation setObject:@YES forKey:@"scores"];
[installation setObject:@YES forKey:@"gameResults"];
[installation setObject:@YES forKey:@"injuryReports"];
[installation saveInBackground];
```
```swift
// Store app language and version
let installation = PFInstallation.currentInstallation()
installation["scores"] = true
installation["gameResults"] = true
installation["injuryReports"] = true
installation.saveInBackground()
```

You can even create relationships between your `Installation` objects and other classes saved on Parse. To associate a PFInstallation with a particular user, for example, you can simply store the current user on the `PFInstallation`.

```objc
// Associate the device with a user
PFInstallation *installation = [PFInstallation currentInstallation];
installation[@"user"] = [PFUser currentUser];
[installation saveInBackground];
```
```swift
// Associate the device with a user
let installation = PFInstallation.currentInstallation()
installation["user"] = PFUser.currentUser()
installation.saveInBackground()
```

#### Sending Pushes to Queries

Once you have your data stored on your `Installation` objects, you can use a `PFQuery` to target a subset of these devices. `Installation` queries work just like any other [Parse query](#queries), but we use the special static method `[PFInstallation query]` to create it. We set this query on our `PFPush` object, before sending the notification.

```objc
// Create our Installation query
PFQuery *pushQuery = [PFInstallation query];
[pushQuery whereKey:@"injuryReports" equalTo:YES];

// Send push notification to query
PFPush *push = [[PFPush alloc] init];
[push setQuery:pushQuery]; // Set our Installation query
[push setMessage:@"Willie Hayes injured by own pop fly."];
[push sendPushInBackground];
```
```swift
// Create our Installation query
let pushQuery = PFInstallation.query()
pushQuery.whereKey("injuryReports", equalTo: true)

// Send push notification to query
let push = PFPush()
push.setQuery(pushQuery) // Set our Installation query
push.setMessage("Willie Hayes injured by own pop fly.")
push.sendPushInBackground()
```

We can even use channels with our query. To send a push to all subscribers of the "Giants" channel but filtered by those who want score update, we can do the following:

```objc
// Create our Installation query
PFQuery *pushQuery = [PFInstallation query];
[pushQuery whereKey:@"channels" equalTo:@"Giants"]; // Set channel
[pushQuery whereKey:@"scores" equalTo:YES];

// Send push notification to query
PFPush *push = [[PFPush alloc] init];
[push setQuery:pushQuery];
[push setMessage:@"Giants scored against the A's! It's now 2-2."];
[push sendPushInBackground];
```
```swift
// Create our Installation query
let pushQuery = PFInstallation.query()
pushQuery.whereKey("channels", equalTo:"Giants") // Set channel
pushQuery.whereKey("scores", equalTo:true)

// Send push notification to query
let push = PFPush()
push.setQuery(pushQuery) // Set our Installation query
push.setMessage("Giants scored against the A's! It's now 2-2.")
push.sendPushInBackground()
```

If we store relationships to other objects in our `Installation` class, we can also use those in our query. For example, we could send a push notification to all users near a given location like this.

```objc
// Find users near a given location
PFQuery *userQuery = [PFUser query];
[userQuery whereKey:@"location"    nearGeoPoint:stadiumLocation withinMiles:@1]

// Find devices associated with these users
PFQuery *pushQuery = [PFInstallation query];
[pushQuery whereKey:@"user" matchesQuery:userQuery];

// Send push notification to query
PFPush *push = [[PFPush alloc] init];
[push setQuery:pushQuery]; // Set our Installation query
[push setMessage:@"Free hotdogs at the Parse concession stand!"];
[push sendPushInBackground];
```
```swift
// Find users near a given location
let userQuery = PFUser.query()
userQuery.whereKey("location", nearGeoPoint: stadiumLocation, withinMiles: 1)

// Find devices associated with these users
let pushQuery = PFInstallation.query()
pushQuery.whereKey("user", matchesQuery: userQuery)

// Send push notification to query
let push = PFPush()
push.setQuery(pushQuery) // Set our Installation query
push.setMessage("Free hotdogs at the Parse concession stand!")
push.sendPushInBackground()
```

## Sending Options

Push notifications can do more than just send a message. In iOS, pushes can also include the sound to be played, the badge number to display as well as any custom data you wish to send. An expiration date can also be set for the notification in case it is time sensitive.

### Customizing your Notifications

If you want to send more than just a message, you will need to use an `NSDictionary` to package all of the data. There are some reserved fields that have a special meaning.

*   **`alert`**:   the notification's message.
*   **`badge`**: _(iOS only)_   the value indicated in the top right corner of the app icon.   This can be set to a value   or to `Increment` in order to increment the current value by 1.
*   **`sound`**: _(iOS only)_   the name of a sound file in the application bundle.
*   **`content-available`**: _(iOS only)_ If you are a writing a [Newsstand](http://developer.apple.com/library/iOS/#technotes/tn2280/_index.html) app, or an app using the Remote Notification Background Mode [ introduced in iOS7](https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html#//apple_ref/doc/uid/TP40013162-SW10) (a.k.a. "Background Push"), set this value to 1 to trigger a background download.
*   **`category`**: _(iOS only)_ the identifier of th   [   `UIUserNotificationCategory`](https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIUserNotificationCategory) for this push notification.
*   **`uri`**: _(Android only)_   an optional field that contains a URI. When the   notification is opened, an `Activity` associate   with opening the URI is launched.
*   **`title`**: _(Android, Windows 8, and Windows Phone 8 only)_   the value displayed in the Android system tray or Windows toast notification.

For example, to send a notification that increases the current badge number by 1 and plays a custom sound, you can do the following:

```objc
NSDictionary *data = @{
  @"alert" : @"The Mets scored! The game is now tied 1-1!",
  @"badge" : @"Increment",
  @"sounds" : @"cheering.caf"
};
PFPush *push = [[PFPush alloc] init];
[push setChannels:@[ @"Mets" ]];
[push setData:data];
[push sendPushInBackground];
```
```swift
let data = [
  "alert" : "The Mets scored! The game is now tied 1-1!",
  "badge" : "Increment",
  "sounds" : "cheering.caf"
]
let push = PFPush()
push.setChannels(["Mets"])
push.setData(data)
push.sendPushInBackground()
```

It is also possible to specify your own data in this dictionary. As we'll see in the [Receiving Notifications](#push-notifications-receiving-pushes) section, you will have access to this data only when the user opens your app via the notification. This can be useful for displaying a different view controller when a user opens certain notifications.

```objc
NSDictionary *data = @{
  @"alert" : @"Ricky Vaughn was injured in last night's game!",
  @"name" : @"Vaughn",
  @"newsItem" : @"Man bites dog"
};
PFPush *push = [[PFPush alloc] init];
[push setQuery:injuryReportsQuery];
[push setChannel:@"Indians"];
[push setData:data];
[push sendPushInBackground];
```
```swift
let data = [
  "alert" : "Ricky Vaughn was injured in last night's game!",
  "name" : "Vaughn",
  "newsItem" : "Man bites dog"
]
let push = PFPush()
push.setQuery(injuryReportsdata)
push.setChannel("Indians")
push.setData(data)
push.sendPushInBackground()
```

Whether your push notifications increment the app's badge or set it to a specific value, your app will eventually need to clear its badge. This is covered in [Clearing the Badge](#push-notifications-receiving-pushes).

### Setting an Expiration Date

When a user's device is turned off or not connected to the internet, push notifications cannot be delivered. If you have a time sensitive notification that is not worth delivering late, you can set an expiration date. This avoids needlessly alerting users of information that may no longer be relevant.

There are two methods provided by the `PFPush` class to allow setting an expiration date for your notification. The first is `expireAtDate:` which simply takes an `NSDate` specifying when Parse should stop trying to send the notification.

```objc
// Create date object for tomorrow
NSDateComponents *comps = [[NSDateComponents alloc] init];
[comps setYear:2015];
[comps setMonth:8];
[comps setDay:14];
NSCalendar *gregorian =
  [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
NSDate *date = [gregorian dateFromComponents:comps];

// Send push notification with expiration date
PFPush *push = [[PFPush alloc] init];
[push expireAtDate:date];
[push setQuery:everyoneQuery];
[push setMessage:@"Season tickets on sale until August 8th!"];
[push sendPushInBackground];
```
```swift
// no swift example
```

There is however a caveat with this method. Since device clocks are not guaranteed to be accurate, you may end up with inaccurate results. For this reason, the `PFPush` class also provides the `expireAfterTimeInterval:` method which accepts an `NSTimeInterval` object. The notification will expire after the specified interval has elapsed.

```objc
// Create time interval
NSTimeInterval interval = 60*60*24*7; // 1 week

// Send push notification with expiration interval
PFPush *push = [[PFPush alloc] init];
[push expireAfterTimeInterval:interval];
[push setQuery:everyoneQuery];
[push setMessage:@"Season tickets on sale until next week!"];
[push sendPushInBackground];
```
```swift
// no swift example
```

### Targeting by Platform

If you build a cross platform app, it is possible you may only want to target devices of a particular operating system. Advanced Targeting allow you to filter which of these devices are targeted.

The following example would send a different notification to Android, iOS, and Windows users.

```objc
PFQuery *query = [PFInstallation query];
[query whereKey:@"channels" equalTo:@"suitcaseOwners"];

// Notification for Android users
[query whereKey:@"deviceType" equalTo:@"android"];
PFPush *androidPush = [[PFPush alloc] init];
[androidPush setMessage:@"Your suitcase has been filled with tiny robots!"];
[androidPush setQuery:query];
[androidPush sendPushInBackground];

// Notification for iOS users
[query whereKey:@"deviceType" equalTo:@"ios"];
PFPush *iOSPush = [[PFPush alloc] init];
[iOSPush setMessage:@"Your suitcase has been filled with tiny apples!"];
[iOSPush setChannel:@"suitcaseOwners"];
[iOSPush setQuery:query];
[iOSPush sendPushInBackground];

// Notification for Windows 8 users
[query whereKey:@"deviceType" equalTo:@"winrt"];
PFPush *winPush = [[PFPush alloc] init];
[winPush setMessage:@"Your suitcase has been filled with tiny glass!"];
[winPush setQuery:query];
[winPush sendPushInBackground];

// Notification for Windows Phone 8 users
[query whereKey:@"deviceType" equalTo:@"winphone"];
PFPush *winPush = [[PFPush alloc] init];
[wpPush setMessage:@"Your suitcase is very hip; very metro."];
[wpPush setQuery:query];
[wpPush sendPushInBackground];
```
```swift
// no swift example
```

## Scheduling Pushes

Sending scheduled push notifications is not currently supported by the iOS SDK. Take a look at the [REST API](/docs/rest/guide/#push-notifications-scheduling-pushes), [JavaScript SDK](/docs/js/guide/#push-notifications-scheduling-pushes) or the Parse.com push console.

## Receiving Pushes

As we saw in the [Customizing Your Notification](#push-notifications-sending-options) section, it is possible to send arbitrary data along with your notification message. We can use this data to modify the behavior of your app when a user opens a notification. For example, upon opening a notification saying that a friend commented on a user's picture, it would be nice to display this picture.

Due to the package size restrictions imposed by Apple, you need to be careful in managing the amount of extra data sent, since it will cut down on the maximum size of your message. For this reason, it is recommended that you keep your extra keys and values as small as possible.

```objc
NSDictionary *data = @{
  @"alert" : @"James commented on your photo!",
  @"p" : @"vmRZXZ1Dvo" // Photo's object id
};
PFPush *push = [[PFPush alloc] init];
[push setQuery:photoOwnerQuery];
[push setData:data];
[push sendPushInBackground];
```
```swift
let data = [
  "alert" : "James commented on your photo!",
  "p" : "vmRZXZ1Dvo" // Photo's object id
]
let push = PFPush()
push.setQuery(photoOwnerQuery)
push.setData(data)
push.sendPushInBackground()
```

### Responding to the Payload

When an app is opened from a notification, the data is made available in the `application:didFinishLaunchingWithOptions:` methods through the `launchOptions` dictionary.

```objc
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  . . .
  // Extract the notification data
  NSDictionary *notificationPayload = launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];

  // Create a pointer to the Photo object
  NSString *photoId = [notificationPayload objectForKey:@"p"];
  PFObject *targetPhoto = [PFObject objectWithoutDataWithClassName:@"Photo"   objectId:photoId];

  // Fetch photo object
  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(PFObject *object, NSError *error) { // Show photo view controller if (!error && [PFUser currentUser]) {   PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];   [self.navController pushViewController:viewController animated:YES]; }
  }];
}
```
```swift
// no swift example
```

If your app is already running when the notification is received, the data is made available in the `application:didReceiveRemoteNotification:fetchCompletionHandler:` method through the `userInfo` dictionary.

```objc
- (void)application:(UIApplication *)application
  didReceiveRemoteNotification:(NSDictionary *)userInfo  fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))handler {
  // Create empty photo object
  NSString *photoId = [userInfo objectForKey:@"p"];
  PFObject *targetPhoto = [PFObject objectWithoutDataWithClassName:@"Photo"   objectId:photoId];

  // Fetch photo object
  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(PFObject *object, NSError *error) { // Show photo view controller if (error) {   handler(UIBackgroundFetchResultFailed); } else if ([PFUser currentUser]) {   PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];   [self.navController pushViewController:viewController animated:YES];   handler(UIBackgroundFetchResultNewData); } else {   handler(UIBackgroundModeNoData); }
  }];
}
```
```swift
func application(application: UIApplication,  didReceiveRemoteNotification userInfo: [NSObject : AnyObject],  fetchCompletionHandler completionHandler: (UIBackgroundFetchResult) -> Void) {
  if let photoId: String = userInfo["p"] as? String { let targetPhoto = PFObject(withoutDataWithClassName: "Photo", objectId: photoId) targetPhoto.fetchIfNeededInBackgroundWithBlock({ (object: PFObject!, error: NSError!) -> Void in   // Show photo view controller   if error != nil { completionHandler(UIBackgroundFetchResult.Failed)   } else if PFUser.currentUser() != nil { let viewController = PhotoVC(withPhoto: object) self.navController.pushViewController(viewController, animated: true) completionHandler(UIBackgroundFetchResult.NewData)   } else { completionHandler(UIBackgroundFetchResult.NoData)   } })
  }
  handler(UIBackgroundFetchResult.NoData)
}
```

You can read more about handling push notifications in Apple's [Local and Push Notification Programming Guide](http://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/IPhoneOSClientImp/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW1).

### Tracking Pushes and App Opens

To track your users' engagement over time and the effect of push notifications, we provide some hooks in the `PFAnalytics` class. You can view the open rate for a specific push notification on the Parse.com push console. You can also view overall app open and push open graphs are on the Parse analytics console.  Our analytics graphs are rendered in real time, so you can easily verify that your application is sending the correct analytics events before your next release.

This section assumes that you've already set up your application to [save the Installation object](#push-notifications-installations). Push open tracking only works when your application's devices are associated with saved `Installation` objects.

First, add the following to your `application:didFinishLaunchingWithOptions:` method to collect information about when your application was launched, and what triggered it. The extra checks ensure that, even with iOS 7's more advanced background push features, a single logical app-open or push-open event is counted as such.

```objc
if (application.applicationState != UIApplicationStateBackground) {
  // Track an app open here if we launch with a push, unless
  // "content_available" was used to trigger a background push (introduced
  // in iOS 7). In that case, we skip tracking here to avoid double
  // counting the app-open.
  BOOL preBackgroundPush = ![application respondsToSelector:@selector(backgroundRefreshStatus)];
  BOOL oldPushHandlerOnly = ![self respondsToSelector:@selector(application:didReceiveRemoteNotification:fetchCompletionHandler:)];
  BOOL noPushPayload = ![launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];
  if (preBackgroundPush || oldPushHandlerOnly || noPushPayload) {
  	[PFAnalytics trackAppOpenedWithLaunchOptions:launchOptions];
  }
}
```
```swift
if application.applicationState != UIApplicationState.Background {
  // Track an app open here if we launch with a push, unless
  // "content_available" was used to trigger a background push (introduced
  // in iOS 7). In that case, we skip tracking here to avoid double
  // counting the app-open.
  let oldPushHandlerOnly = !self.respondsToSelector(Selector("application:didReceiveRemoteNotification:fetchCompletionHandler:"))
  let noPushPayload: AnyObject? = launchOptions?[UIApplicationLaunchOptionsRemoteNotificationKey]?
  if oldPushHandlerOnly || noPushPayload != nil {
  	PFAnalytics.trackAppOpenedWithLaunchOptions(launchOptions)
  }
}
```

Second, if your application is running or backgrounded, the `application:didReceiveRemoteNotification:` method handles the push payload instead. If the user acts on a push notification while the application is backgrounded, the application will be brought to the foreground. To track this transition as the application being "opened from a push notification," perform one more check before calling any tracking code:

```objc
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
	if (application.applicationState == UIApplicationStateInactive) {
		// The application was just brought from the background to the foreground,
		// so we consider the app as having been "opened by a push notification."
		[PFAnalytics trackAppOpenedWithRemoteNotificationPayload:userInfo];
	}
}
```
```swift
// no swift example
```

Finally, if using iOS 7 any of its new push features (including the new "content-available" push functionality), be sure to also implement the iOS 7-only handler:

```objc
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  if (application.applicationState == UIApplicationStateInactive) { [PFAnalytics trackAppOpenedWithRemoteNotificationPayload:userInfo];
  }
}
```
```swift
func application(application: UIApplication,  didReceiveRemoteNotification userInfo: [NSObject : AnyObject],  fetchCompletionHandler completionHandler: (UIBackgroundFetchResult) -> Void) {
  if application.applicationState == UIApplicationState.Inactive { PFAnalytics.trackAppOpenedWithRemoteNotificationPayload(userInfo)
  }
}
```

#### Tracking on OS X

If your OS X application supports receiving push notifications and you'd like to track application opens related to pushes, add hooks to the `application:didReceiveRemoteNotification:` method (as in iOS) and the following to `applicationDidFinishLaunching:`

```objc
- (void)applicationDidFinishLaunching:(NSNotification *)notification {
  // ... other Parse setup logic here
  [PFAnalytics trackAppOpenedWithRemoteNotificationPayload:[notification userInfo]];
}
```
```swift
func applicationDidFinishLaunching(notification: NSNotification) {
  // ... other Parse setup logic here
  PFAnalytics.trackAppOpenedWithRemoteNotificationPayload(notification.userInfo)
}
```

#### Tracking Local Notifications (iOS only)

To track analytics around local notifications, note that `application:didReceiveLocalNotification:` is called _in addition to_ `application:didFinishLaunchingWithOptions:`, if implemented. Please be careful to prevent tracking duplicate events.

#### Clearing the Badge

A good time to clear your app's badge is usually when your app is opened. Setting the badge property on the current installation will update the application icon badge number and ensure that the latest badge value  will be persisted to the server on the next save. All you need to do is:

```objc
- (void)applicationDidBecomeActive:(UIApplication *)application {
  PFInstallation *currentInstallation = [PFInstallation currentInstallation];
  if (currentInstallation.badge != 0) { currentInstallation.badge = 0; [currentInstallation saveEventually];
  }
  // ...
}
```
```swift
func applicationDidBecomeActive(application: UIApplication) {
  let currentInstallation = PFInstallation.currentInstallation()
  if currentInstallation.badge != 0 { currentInstallation.badge = 0 currentInstallation.saveEventually()
  }
  // ...
}
```

The [UIApplicationDelegate documentation](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html) contains more information on hooks into an app’s life cycle; the ones which are most relevant for resetting the badge count are  `applicationDidBecomeActive:`,  `application:didFinishLaunchingWithOptions:`,  and `application:didReceiveRemoteNotification:`.

## Push Experiments

You can A/B test your push notifications to figure out the best way to keep your users engaged. With A/B testing, you can simultaneously send two versions of your push notification to different devices, and use each version's push open rates to figure out which one is better.  You can test by either message or send time.

### A/B Testing

Our web push console guides you through every step of setting up an A/B test.

For each push campaign sent through the Parse web push console, you can allocate a subset of your devices to be in the experiment's test audience, which Parse will automatically split into two equally-sized experiment groups. For each experiment group, you can specify a different push message. The remaining devices will be saved so that you can send the winning message to them later. Parse will randomly assign devices to each group to minimize the chance for a test to affect another test's results (although we still don't recommend running multiple A/B tests over the same devices on the same day).

![](/images/docs/ios_push/experiment_enable.png)

After you send the push, you can come back to the push console to see in real time which version resulted in more push opens, along with other metrics such as statistical confidence interval. It's normal for the number of recipients in each group to be slightly different because some devices that we had originally allocated to that experiment group may have uninstalled the app. It's also possible for the  random group assignment to be slightly uneven when the test audience size is small. Since we calculate open rate separately for each group based on recipient count, this should not significantly affect your experiment results.

![](/images/docs/ios_push/experiment_results.png)

If you are happy with the way one message performed, you can send that to the rest of your app's devices (i.e. the “Launch Group”). This step only applies to A/B tests where you vary the message.

<img src="https://parse.com/images/docs/ios_push/experiment_launch.png" style="width=400px"/>

Push experiments are supported on all recent Parse SDKs (iOS v1.2.13+, Android v1.4.0+, .NET v1.2.7+). Before running experiments, you must instrument your app with [push open tracking](#push-notifications-tracking-pushes-and-app-opens).

### Experiment Statistics

Parse provides guidance on how to run experiments to achieve statistically significant results.

#### Test Audience Size

When you setup a push message experiment, we'll recommend the minimum size of your test audience. These recommendations are generated through simulations based on your app's historical push open rates. For big push campaigns (e.g. 100k+ devices), this recommendation is usually small subset of your devices. For smaller campaigns (e.g. < 5k devices), this recommendation is usually all devices. Using all devices for your test audience will not leave any remaining devices for the launch group, but you can still gain valuable insight into what type of messaging works better so you can implement similar messaging in your next push campaign.

#### Confidence Interval

After you send your pushes to experiment groups, we'll also provide a statistical confidence interval when your experiment has collected enough data to have statistically significant results. This confidence interval is in absolute percentage points of push open rate (e.g. if the open rates for groups A and B are 3% and 5%, then the difference is reported as 2 percentage points). This confidence interval is a measure of how much difference you would expect to see between the two groups if you repeat the same experiment many times.

Just after a push send, when only a small number of users have opened their push notifications, the open rate difference you see between groups A and B could be due to random chance, so it might not be reproducible if you run the same experiment again. After your experiment collects more data over time, we become increasingly confident that the observed difference is a true difference. As this happens, the confidence interval will become narrower, allowing us to more accurately estimate the true difference between groups A and B. Therefore, we recommend that you wait until there is enough data to generate a statistical confidence interval before deciding which group's push is better.

## Troubleshooting

Setting up Push Notifications is often a source of frustration for developers.  The process is complicated and invites problems to happen along the way. If you  run into issues, try some of these troubleshooting tips.

*   Make sure you are using the correct Bundle Identifier in th   `Info.plist` file (as described in step 4.1 of th   [iOS Push Notifications tutorial](/tutorials/ios-push-notifications),   titled, "Configuring a Push Enabled iOS Application."
*   Make sure you set the correct provisioning profile in Project > Build Setting   (as described in step 4.3 of the iOS Push Notifications tutorial.
*   Clean your project and restart Xcode.
*   Try regenerating the provisioning profile by navigating t   [Certificates   Identifiers & Profiles](https://developer.apple.com/account/overview.action), changing the App ID set on the provisioning profile   and changing it back. You will need to reinstall the profile as described in step   two of the tutorial (Creating the Provisioning Profile) and set it in your Project'   Build Settings as described in step 4 ( Configuring a Push Enabled iO   Application).
*   Open the Xcode Organizer and delete all expired and unused provisionin   profiles from both your computer and your iOS device.
*   If everything compiles and runs with no errors, but you are still not receivin   pushes, make sure that your app has been given permission to receive notifications   You can verify this in your iOS device's `Settings > Notification    YourAppName`.*   If your app has been granted permission to receive push notifications, make sur   that you are code signing your app with the correct provisioning profile. If yo   have uploaded a Development Push Notification Certificate to Parse, you will onl   receive push notifications if you built your app with a Development Provisionin   Profile. If you have uploaded a Production Push Notification Certificate, you shoul   sign your app with a Distribution Provisioning Profile. Ad Hoc and App Stor   Distribution Provisioning Profiles should both work when your app is configure   with a Production Push Notification Certificate.
*   When enabling push notifications for an existing App ID in the Apple iO   Provisioning Portal, make sure to regenerate the provisioning profile, then ad   the updated profile to the Xcode Organizer.
*   Distribution push notifications need to be enabled prior to submitting an ap   to the App Store. Make sure you have followed Section 7, Preparing for the Ap   Store, prior to submitting your app. If you skipped any of these steps, you migh   need to submit a new binary to the App Store.
*   Double check that your app can receive distribution push notification   when signed with an Ad Hoc profile. This configuration is the closest you can ge   to an App Store provisioned app.
*   Check the number of recipients in your Parse.com push console. Does it match the   expected number of recipients? Your push might be targeted incorrectly.
*   If your app has been released for a while, it's possible for the recipient estimate   on the push composer page to be higher than the pushes sent value on the push results page.   The push composer estimate is generated via running your push segment query over   your app's installation table.  We do not automatically delete installation objects when   the users uninstall your app.  When we try to send a push, we detect uninstalled   installations and do not include them in the pushes sent value on the results page.
